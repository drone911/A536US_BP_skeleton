##[NR_SCC] InitTcxoOffset : dl_freq(%d), path_info_idx(%d), xo_freq_offset(%d), dmixer_ref(%d), resume_type(%d), rxf_mode(%d), cal_xo_freq_offset(%d)
##[NR_SCC] NrModulePathAlloc: There is no available path for module switch, path_info_idx(%d), m_path_always_enable(%d)
##[NR_SCC] NrModulePathAlloc, CA Config FULL, module_path_info_idx(%d)
##[NR_SCC] NrModulePathAlloc, CA ACT FULL, Module path forced alloc
##[NR_SCC] NrModulePathAlloc, CA ACT FULL, stop NR path allocation
##[NR_SCC] NR RF INFO : check current total_rfbw (%d), bitmask(0x%x), bw(%d), total_bw (%d)Mhz
##[NR_SCC] NrModulePathAlloc, exception_case, total_bw %d Mhz
##[NR_SCC] NrPathAlloc, Normal case, module_path_info_idx : %d
##[NR_SCC] just after the GAP CMD trigger path_info_idx %d
##[NR_SCC] NrModulePathAlloc, Module path alloc %d
##[NR_SCC] GetNumUsedNrPath:: num_used_pathalloc(%d)
##[NR_SCC] GetNumAvailNrPath:: num_avail_path alloc(%d)
##[NR_SCC] NrPathAlloc_with_Core : cell_info_idx %d, path_info_idx %d, div_path %d
##[NR_SCC] GetDemodCcIdx : %d
##[NR_SCC] REDUCED_INFO : domain_type(%d), mxr(%d), demodcc(%d), reduced_mode(%d), check_2layer(%d)
##[NR_SCC] 2LAYER_INFO : domain_type(%d), mxr(%d), demodcc(%d), reduced_mode(%d), check_2layer(%d)
##[NR_SCC] check LTE DEACT case : cell_id %d
##[NR_SCC] LTE DEACT case : cell_id %d
##[NR_SCC] NrPathAlloc : core_idx(%d), MXR(%d), RTG(%d), TDBUF(%d), OUTPUT(%d), DEMOD(%d), RF_RTG(%d)
##[NR_SCC] NrPathAlloc fail : OUTPUT_SEL_IDX %d, TDBUF_SEL_IDX %d
##[NR_SCC] NrPathAlloc : core_idx(%d), MXR(%d), RTG(%d), TDBUF(%d), OUTPUT(%d), DEMOD(%d), RF_RTG(%d)
##[NR_SCC] NrPathAlloc : cell_info_idx (%d), pri_path_idx (%d), div_path(%d)
##[NR_SCC] DSDS: same path with LTE path_info(%d)
##[NR_SCC] NrPathAlloc fail: There is no available path %d
##[NR_SCC] NrPathAlloc fail: There is no available path for the given cell(%d, %d)!!!
##[NR_SCC] Pcell case, path_info(%d), pcell_freq(%d), pcell_afc(%d), scell_freq(%d), scell_afc(%d)
##[NR_SCC] GetDemodCcIdx : %d
##[NR_SCC] NrPathAlloc : path_info(%d), allocated arfcn(%d), freq(%d), band(%d), dl_bw(%d), path_info_idx_occupied(0x%x), req_status(%d)
##[NR_SCC] NrPathDeAlloc : cell_info(%d), div_path(%d), m_PathInfoDb->path_info(%d)
##[NR_SCC][WARNING] NrPathDeAlloc : Please check path index
##[NR_SCC] DecideRxfConfigType : Invalid modify_status(%d)
##[NR_SCC] DecideRxfConfigType : modify_status(%d) RxfConfigType(%d)
##[NR_SCC][WARNING] Abnormal modify_status(%d), path_info[%d].status(%d)
##[NR_SCC] SetPathInfo : path_info_idx#(%d) => modify_status(%s), rf_chg_type(%d), rx_mode(0x%x), agc_mode(%d)
##[NR_SCC] SetPathInfo : path_info_idx#(%d) => modify_status(%s), rf_chg_type(%d), rx_mode(0x%x), agc_mode(%d)
##[NR_SCC] PrevRfCmdProcess : skip RF cmd process, rf_chg_type(%d)
##[NR_SCC][WARNING] Abnormal cell_info_idx[%d] pri_path_idx(%d)
##[NR_SCC] PrevRfCmdProcess : rf_path_idx %d rf_rx_mode 0x%x prx_bitmask 0x%x drx_bitmask 0x%x
##[NR_SCC] PrevRfCmdProcess : cell_info_idx(%d), div_path_idx(%d) allocatied
##[NR_SCC] SetPathInfo: Do not send filter cmd!
##[NR_SCC] Enable4Rx:: cell_info_idx(%d), path_info_idx(%d, %d)
##[NR_SCC] Config4Rx : No support 4Rx band, DR_PATH is using in LTE! cell_info_idx(%d), using_dr_path(%d), band(%d)
##[NR_SCC] Enable4Rx:: NrPathDeAlloc
##[NR_SCC] Enable4Rx : check_4rx_path_config(0x%x)
##[NR_SCC] Disable4Rx:: cell_info_idx(%d), path_info_idx(%d, %d), rf_path(%d, %d)
##[NR_SCC] Disable4Rx : Tx1 off, current_tx_mode(%d), Pcell rx_mode(%d)
##[NR_SCC] Config4Rx : mode(%d), enable(%d), rf_band(%d), using_dr_path(%d)
##[NR_SCC] /for DBG/ GetDivSloPath : pri_rf_path(%d), slo_path[%d](%d, %d)
##[NR_SCC] /for DBG/ GetDivSloPath : slo_div_rf_path(%d)
##[NR_SCC] Config4Rx : NR_AP_EVENT_OH_RX_MODE set No action
##[NR_SCC] Set4RxPath enable:: buf not enough!! cell_info(%d), avail_fdbuf(%d), fdbuf(%d), avail_ecb(%d), ecb(%d), avail_mcw(%d), mcw(%d)
##[NR_SCC] Set4RxPath enable:: cell_info(%d), pri_path(%d), div_path_idx(%d)
##[NR_SCC] Set4RxPath enable:: cell_info(%d), pri_path(%d) not alloc div_path !!
##[NR_SCC] Set4RxPath enable:: cell_info_idx(%d), Backup4RxMode(%d)
##[NR_SCC] Set4RxPath:: enable(%d) cell_info(%d), path_info(%d, %d), rf_path(%d, %d), dmxr_freq_slo(%d)
##[NR_SCC] postpone NrAntennaModeChange:: cc(%d) rx_mode(0x%x) measmode(%d) req_status(%d)
##[NR_SCC] skip NrAntennaModeChange:: cc(%d) rx_mode(0x%x) measmode(%d) req_status(%d)
##[NR_SCC] skip NrAntennaModeChange, cause: cell_info_idx(%d), Requested rx_mode(%d), rsm_grant(%d), pri_path_idx(%d), ConfigNum(%d), req_status(%d)
##[NR_SCC] Invalid antenna mode change req, Check Scell Act first! current_antenna_mode(%d), Requested rx_mode(%d)
##[NR_SCC] NrAntennaModeChange - use RXD.TEST_MODE: requested rx_mode(%d -> %d)
##[NR_SCC] NrAntennaModeChange - Not use RXD.TEST_MODE: requested rx_mode(%d -> %d)
##[NR_SCC] NrAntennaModeChange - RXD.TEST_MODE: requested rx_mode(%d -> %d)
##[NR_SCC] NrAntennaModeChange : cell_idx(%d), path_info_idx(%d, %d), rxf_mode(%d), antenna_mode(%d -> %d)
##[NR_SCC] drx1 path on/off: pri_path_idx(%d), rx_mode(%d), rf_on(%d)
##[NR_SCC] div_path_idx(%d), rx_mode(%d)
##[NR_SCC] GetCellInfoIdx : path_info_idx(%d) RF_PATH_IDX(%d) MXR_SEL_IDX(%d) DEMOD_SEL_IDX(%d) arg(%d)
##[NR_SCC][WARNING] Undefined find_param(%d)
##[NR_SCC] GetDemodCcIdx : found_demod_cc(%d), used_demod_cc(0x%x) MAX_DEMOD_CC(%d)
##[NR_SCC] GetDemodCcIdx : Max demod path allocated, used_demod_cc(0x%x)
##[NR_SCC] UpdateRfInfo : cell(%d), path(%d), rf(%d), type(%x), path_info_bitmask(0x%x), prx_bitmask(0x%x), drx_bitmask(0x%x)
##[NR_SCC] UpdateRfInfo : rf(%d), dl_arfcn(%d), dl_bw(%d), ul_arfcn(%d), ul_bw(%d), ant_bitmask(0x%x, 0x%x)
##[NR_SCC] ConfigModuleCaPath module_op_state %d, serv_module_idx 0x%x target_module_idx 0x%x serv_module %d target_module %d vh_path %d rf_interface %d
##[NR_SCC] MODULE_CONFIG_MONITOR : pri_rf_path %d measure_rf_path %d
##[NR_SCC] MODULE_CONFIG_MONITOR : pri_rf_path %d measure_rf_path %d
##[NR_SCC][ERROR] abnormal module_path_idx!!!
##[NR_SCC] enable module path (path %d, rf path %d)
MODULE_MONITOR_END : pri_rf_path %d measure_rf_path %d
MODULE_MONITOR_END : already end, return
##[NR_SCC] just after restore ca path info %d rx_mode 0x%x
##[NR_SCC] just after GAP config cmd, cell_info_idx %d path_info_idx %d scell_idx %d
##[NR_SCC] release module path (path %d, rf path %d)
MODULE_SWITCH_BOTH pri_rf_path %d measure_rf_path
module switch act path cell_info[%d] scell_idx [0x%x] path_info[%d] switch_rf_path[%d]
module switch act path cell_info[%d] scell_idx [0x%x] path_info[%d] switch_rf_path[%d]
module switch config path cell_info[%d] scell_idx [0x%x] path_info[%d] switch_rf_path[%d]
##[NR_SCC] switch module (path %d, switch RF path %d => %d) vh_path %d
##[NR_SCC] change module rf_path %d ===> %d
##[NR_SCC] MODULE_ABB_CHECK serv_module %d target_module %d
##[NR_SCC] change module : serv_module(%d) ===> target_module(%d), MODULE_ABB_CHECK : pri_rf_path(%d) ===> switch_rf_path(%d)
##[NR_SCC] MODULE_ABB_CHECK : module is not changed
##[NR_SCC][WARNING] ConfigModuleCaPath error module_op_state %d
##[NR_SCC] SendGapConfigCmd, Send: GAP_CONFIG Command to HAL, mode: %d scell_idx %d
##[NR_SCC] GAP_CONFIG_CMD is running.
##[NR_SCC] ConvertPathReqToCellStatus : invalid path_req_type(%d)
##[NR_SCC]ConvertBw bw_idx %d bandwidth %d
##[NR_SCC] GetNrUnessenDivFdBufSize:: total_fdbuf_size(%d)
##[NR_SCC] GetNrFdBufSize::fored 100Mz
##[NR_SCC] GetNrFdBufSize::is_essen(%d), is_used(%d), total_fdbuf(%d)
##[NR_SCC]GetNrAvailFdBufSize::is_used(%d) avail_fdbuf(%d)
##[NR_SCC]GetNrAvailFdBufSize < 0!!!!
##[NR_SCC]GetNrRemainFdBufSize::path_request(%d) remain_fdbuf(%d)
##[NR_SCC]GetNrRemainFdBufSize < 0!!!!
##[NR_SCC]GetNrRemainFdBufSize: LteFdBufSize is larger than remain_fdbuf.
##[NR_SCC] GetNrUnessenDivEcbSize:: total_ecb_size(%d)
##[NR_SCC] GetNrEcbSize::fored 100Mz
##[NR_SCC] GetNrEcbSize::is_essen(%d), is_used(%d), total_ecb(%d)
##[NR_SCC]GetNrAvailEcbSize::is_used(%d) avail_ecb(%d)
##[NR_SCC]GetNrAvailEcbSize < 0!!!!
##[NR_SCC]GetNrRemainEcbSize::path_request(%d) remain_ecb(%d)
##[NR_SCC]GetNrRemainEcbSize < 0!!!!
##[NR_SCC]GetNrRemainEcbSize: LteEcbBufSize is larger than remain_ecb.
##[NR_SCC] GetNrUnessenDivMcwSize:: total_mcw_size (%d)
##[NR_SCC] GetNrMcwSize::fored 100Mz
##[NR_SCC] GetNrMcwSize::is_essen(%d), is_used(%d), total_Mcw(%d)
##[NR_SCC]GetNrAvailMcwSize::is_used(%d) avail_mcw(%d)
##[NR_SCC]GetNrAvailMcwSize < 0!!!!
##[NR_SCC]GetNrRemainMcwSize::path_request(%d) remain_mcw(%d)
##[NR_SCC]GetNrRemainMcwSize < 0!!!!
##[NR_SCC]GetNrRemainMcwSize: LteMcwSize is larger than remain_mcw.
##[NR_SCC] GetDemodCoreIdx cell_info_idx %d, div_path %d
##[NR_SCC] cell_info_idx %d, div_path %d, core_idx %d
##[NR_SCC] GetCoreIdx : div_path (%d), core_idx(%d), core[0](buffer %d, processing %d), core[1](buffer %d, processing %d)
=====================phase 1, m_pcell_buffer_sum_backup %d buffer_sum %d===========
##[NR_SCC] Pcell original PrintLTECoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
##[NR_SCC] Pcell original PrintNRCoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
##[NR_SCC] Pcell original PrintTotalCoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
=====================phase 2==============================================
##[NR_SCC] Pcell update before PrintLTECoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
##[NR_SCC] Pcell update before update before PrintNRCoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
##[NR_SCC] Pcell update before update before PrintTotalCoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
=====================phase 3==============================================
##[NR_SCC] Pcell update final PrintLTECoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
##[NR_SCC] Pcell update final PrintNRCoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
##[NR_SCC] Pcell update final PrintTotalCoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
=====================REDUCED_INFO==============================================
##[NR_SCC] Pcell original PrintLTECoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
##[NR_SCC] Pcell original PrintNRCoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
##[NR_SCC] Pcell original PrintTotalCoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
##[NR_SCC] Pcell FORCED REDUCED_INFO PrintTotalCoreWorkLoad : core[0](%d, %d), core[1](%d, %d), div_path_idx(%d), reduced_mode(%d)
##[NR_SCC] REDUCED_INFO error
##[NR_SCC] REDUCED_INFO, rx_ratio %d, scs %d, buffer_sum %d, processing_sum %d
##[NR_SCC] original PrintLTECoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
##[NR_SCC] original PrintNRCoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
##[NR_SCC] original PrintTotalCoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
##[NR_SCC] CORE1 FORCED REDUCED_INFO PrintTotalCoreWorkLoad : core[0](%d, %d), core[1](%d, %d), div_path_idx(%d), reduced_mode(%d), DEMOD_SEL_IDX %d
##[NR_SCC] SetCoreWorkLoad : resume_type %d, cell_info_idx %d, pri_path_idx %d, check_scaling_factor %d
##[NR_SCC] cell_info_idx (%d), pri_path_idx (%d), scs(%d, %d)
##[NR_SCC] cell_info_idx (%d), pri_path_idx (%d), scs(%d, %d)
##[NR_SCC] Before NRCore calculate : scs(%d), NR_bw(%d), rx_ratio(%d), total_core0_bf_sum(%d, %d), total_core1_bf_sum(%d, %d)
##[NR_SCC] pre_calclation buffer_sum (%d),processing_sum(%d), (total) core0 b/f(%d, %d), core 1 b/f(%d, %d), case 8 (%d)
##[NR_SCC] case1 %d, case2 %d, case3 %d, case4 %d, case5 %d, case6 %d, case8 %d
##[NR_SCC] case1 SetNRCore core_idx(%d), buffer_sum(%d), processing_sum(%d), total_core[0](%d, %d), total_core[1](%d, %d)
##[NR_SCC] case2 SetNRCore core_idx(%d), buffer_sum(%d), processing_sum(%d), total_core[0](%d, %d), total_core[1](%d, %d)
##[NR_SCC] case5 REDUCED_INFO SetNRCore core_idx(0), buffer_sum(%d, %d), processing_sum(%d)
##[NR_SCC] Pcell REDUCED_INFO domain_type(%d), mxr(%d), demodcc(%d)
##[NR_SCC] REDUCED_INFO SetNRCore core_idx(0), mxr_path[%d], buffer_sum(%d), processing_sum(%d), total_core[0](%d, %d), total_core[1](%d, %d)
##[NR_SCC] case6 reduced SetNRCore core_idx(1), buffer_sum(%d, %d), processing_sum(%d)
##[NR_SCC] reduced SetNRCore core_idx(1), mxr_path[%d], buffer_sum(%d), processing_sum(%d), total_core[0](%d, %d), total_core[1](%d, %d)
##[NR_SCC] case7 SetNRCore core_idx(%d), buffer_sum(%d), processing_sum(%d), total_core[0](%d, %d), total_core[1](%d, %d)
##[NR_SCC] case8 SetNRCore core_idx(%d), buffer_sum(%d), processing_sum(%d), total_core[0](%d, %d), total_core[1](%d, %d)
##[NR_SCC] else case REDUCED_INFO SetNRCore core_idx(0), buffer_sum(%d, %d), processing_sum(%d)
##[NR_SCC] case3 SetNRCore core_idx(%d), buffer_sum(%d), processing_sum(%d), total_core[0](%d, %d), total_core[1](%d, %d)
##[NR_SCC] After NRCore calculate : scs(%d), bw(%d), rx_ratio(%d), total_core0_bf_sum(%d, %d), total_core1_bf_sum(%d, %d)
##[NR_SCC] RECEIVED_CORE PrintLTECoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
##[NR_SCC] CNF_CORE PrintLTECoreWorkLoad : core[0](%d, %d), core[1](%d, %d) [*1000] => : core[0,170500](%d, %d), core[1,147800](%d, %d)
##[NR_SCC] CNF_CORE PrintNRCoreWorkLoad : core[0](%d, %d), core[1](%d, %d) [*1000] => : core[0,170500](%d, %d), core[1,147800](%d, %d)
##[NR_SCC] CNF_CORE PrintTotalCoreWorkLoad : core[0](%d, %d), core[1](%d, %d) [*1000] => : core[0,170500](%d, %d), core[1,147800](%d, %d)
##[NR_SCC] CNF_CORE PrintCoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
##[NR_SCC] PrintNRCoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
##[NR_SCC] PrintLTECoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
##[NR_SCC] PrintTotalCoreWorkLoad : core[0](%d, %d), core[1](%d, %d)
##[NR_SCC] SetRtgSel (core_idx %d, cell_info_idx %d, path_info_idx %d)
##[NR_SCC] SetTdbufSel (core_idx %d, cell_info_idx %d, path_info_idx %d)
##[NR_SCC] SetOutputSel (core_idx %d, cell_info_idx %d, path_info_idx %d)
##[NR_SCC][WARNING] CheckValid4RxPath : 4Rx is not supported!!! Requested rx_mode(B: 0x%x -> A: 0x%x)
##[NR_SCC] GetNumConfigDoneCell : ConfigDoneCell(%d)
##[NR_SCC] TxModeChangeCb : changed_tx_mode(%d), [test]NrDb/Drx_saved_tx_mode(%d)
